#codewars codes

''' #5Kyu

bonus = 1500
price = 2
#expected output -----> 12

def beeramid(bonus, price):

    if price <= 0:
        raise ValueError("Price must be greater than 0!!!")
    
    if bonus <= 0:
        return 0

    can_beer = bonus // price
    level = 1
    used = 0

    while used <= can_beer:
        used += level**2
        if used <= can_beer:
            level += 1
        else:
            level -= 1
            break
    return level
print (beeramid(bonus, price))

#version level up
def beeramid(bonus: int, price: int) -> int:

    if price <= 0:
        raise ValueError("Price must be greater than zero.")

    if bonus <= 0:
        return 0

    total_cans = bonus // price

    level = 1
    used_cans = 0

    while used_cans + level**2 <= total_cans:
        used_cans += level**2
        level += 1

    return level -1
print (beeramid(bonus, price))
'''


''' #6Kyu

walk = ['n','s','n','s','n','s','n','s','n','s'] #true

def length(walk):
        
    return len(walk) == 10
        
def position(walk):

    return walk.count('n') == walk.count('s') and walk.count('e') == walk.count('w')

def is_valid_walk(walk):

    return length(walk) and position(walk)

print (is_valid_walk(walk))

#second version
def is_valid_walk(walk):
    if len(walk) != 10:
        return False

    return walk.count('n') == walk.count('s') and \
           walk.count('e') == walk.count('w')
'''


''' #7Kyu

dnaa = "ATTGC" #--> "TAACG"
dna = "GTAT" #--> "CATA"
dnaa = "BXB"

def DNA_strand(dna):
    new_dna = []

    for x in dna:
        if x == "A":
            new_dna.append("T")
        elif x == "T":
            new_dna.append("A")
        elif x == "G":
            new_dna.append("C")
        elif x == "C":
            new_dna.append("G")
        else:
            print(f"No such {x} letter in DNA!")
    return ''.join(new_dna)

print(DNA_strand(dna))

#second version
def DNA_strand(dna):
    mapping = {
        "A": "T",
        "T": "A",
        "C": "G",
        "G": "C",
    }

    result = []

    for x in dna:
        try:
            result.append(mapping[x])
        except KeyError:
            raise ValueError(f"Invalid DNA character: {x}")

    return ''.join(result)
print(DNA_strand(dna))
'''


''' #6Kyu

s = "CamelCasing"

def solution(s):

    words = ""

    for x, char in enumerate(s):
        if char.isupper() and x != 0:
            words += " " + char
        else:
            words += char

    return words
print(solution(s))
'''


''' #4Kyu

text = "e e e e DDD ddd DdD: ddd ddd aa aA Aa, bb cc cC e e e I'am Bartosz!" #--> ["e", "ddd", "aa"]
ttext = " '' "

import re
from itertools import islice

def top_3_words(text):

    repeat = {}
    low = text.lower()
    pattern = "[a-z']+"
    r = re.findall(pattern, low)

    for word in r:
        if word.replace("'", "") == "":
            continue
        if word not in repeat:
            repeat[word] = 1
        else:
            repeat[word] += 1
        
        #value = r.count(word)
        #repeat[word] = value

    sort = dict(sorted(repeat.items(), key = lambda item: item[1], reverse=True))
    best_word = list(islice(sort, 0, 3))

    return best_word
print(top_3_words(text))

#druga wersja kodu tego powyżej, lepsza, wydajniejsza
#second version

import re

def top_3_words(text):
    words = re.findall("[a-z']+", text.lower())

    counts = {}
    for w in words:
        if w.strip("'") == "":
            continue
        counts[w] = counts.get(w, 0) + 1

    top3 = []

    for word, count in counts.items():
        top3.append((word, count))
        top3 = sorted(top3, key=lambda x: x[1], reverse=True)[:3]

    return [word for word, _ in top3]
'''


''' #5Kyu

r = 148
g = 0 
b = 211   #--> "9400D3"

def check_rgb(n):
    min_val = 0
    max_val = 255

    if n < min_val:
        return min_val
    elif n > max_val:
        return max_val
    else:
        return n

def rgb(r, g, b):

    wynik = []
    wynik.append(hex(check_rgb(r)).upper()[2:])
    wynik.append(hex(check_rgb(g)).upper()[2:])
    wynik.append(hex(check_rgb(b)).upper()[2:])

    new = []
    for w in wynik:
        if 1 == len(w):
            w = '0' + w
            new.append(w)
        else:
            new.append(w)

    return ''.join(new)
    
print(rgb(r, g, b))

#Senior, better version of my code
def rgb(r, g, b):
    def clamp(n):
        return max(0, min(255, n))

    return (
        f"{clamp(r):02X}"
        f"{clamp(g):02X}"
        f"{clamp(b):02X}"
    )
'''


''' #5Kyu

import string
ttext = 'Pig latin is cool' # igPay atinlay siay oolcay
text = 'Hello, . world! !'    # elloHay orldway !

def pig_it(text):
    txt = text.split()
    new = []
    for word in txt:
        punct = ""
        if word[-1] in string.punctuation:
            punct = word[-1]
            word = word[:-1]
        if word.isalpha():
            word = word[1:] + word[0] + "ay" + punct
            new.append(word)
        else:
            word += punct
            new.append(word)
            
    return " ".join(new)

print(pig_it(text))

#wersja pro tego mojego kodu, ulepszona
#second version - pro

import string

def pig_it(text):
    result = []

    for word in text.split():
        # jeśli w słowie NIE MA ANI JEDNEJ litery → zostaw bez zmian
        if not any(ch.isalpha() for ch in word):
            result.append(word)
            continue

        # oddzielamy interpunkcję z końca
        punct = ""
        while word and word[-1] in string.punctuation:
            punct = word[-1] + punct
            word = word[:-1]

        # Pig Latin
        word = word[1:] + word[0] + "ay"

        # doklejamy interpunkcję
        result.append(word + punct)

    return " ".join(result)
'''


''' #6Kyu

okroman = "MM"      #-> 2000
roman = "MDCLXVI" #-> 1666
okroman = "M"       #-> 1000
okroman = "CD"      #->  400
okroman = "XC"      #->   90
okroman = "XL"      #->   40
okroman = "I"       #->    1

def solution(roman : str) -> int:
    
    total = 0
    
    values = {
        "I": 1,
        "V": 5,
        "X": 10,
        "L": 50,
        "C": 100,
        "D": 500,
        "M": 1000}
    
    for r in range(len(roman)):
        #print(r)
        #print("to", roman[r])
        #print("to war", values[roman[r]])
        if r+1 < len(roman):
            #print("r+1", roman[r+1])
            #print("r+1 war", values[roman[r+1]])
            if values[roman[r]] < values[roman[r+1]]:
                total -= values[roman[r]]
            else:
                total += values[roman[r]]
        else:
            total += values[roman[r]]

    return total

print(solution(roman))


#lepsza wersja tego kodu powyżej na poziomie seniora
#seniority lvl of my code

def solution(roman):
    values = {"I":1,"V":5,"X":10,"L":50,"C":100,"D":500,"M":1000}
    total = 0

    for i in range(len(roman)):
        total += values[roman[i]]

        if i+1 < len(roman) and values[roman[i]] < values[roman[i+1]]:
            total -= 2 * values[roman[i]]

    return total
'''


''' #6Kyu

iintegers = [2, 4, 0, 100, 4, 11, 2602, 36] #-->  11 (the only odd number)

iintegers = [160, 3, 1719, 19, 11, 13, -21] #--> 160 (the only even number)

integers = [17, 6, 8, 10, 6, 12, 24, 36]

def find_outlier(integers):
    odd = []
    even = []
    for i in integers:
        if i % 2 == 0:
            even.append(i)
        else:
            odd.append(i)
    if len(even) > len(odd):
        return odd[0]
    if len(odd) > len(even):
        return even[0]

print (find_outlier(integers))
'''


''' #6Kyu

names0 = []                                #-->  "no one likes this"
names3 = ["Peter"]                          #-->  "Peter likes this"
names1 = ["Jacob", "Alex"]                 #-->  "Jacob and Alex like this"
names2 = ["Max", "John", "Mark"]           #-->  "Max, John and Mark like this"
names = ["Alex", "Jacob", "Mark", "Max"]  #-->  "Alex, Jacob and 2 others like this"

def likes(names):
    length = len(names)
    other = str(length - 2) + ' others'
    like = ' like this'
    if length == 0:
        ans = 'no one likes this'
    elif length == 1:
        ans =  names[0] + ' likes this'
    elif length == 2:
        ans =  names[0] + ' and ' + names[1] + like
    elif length == 3:
        ans =  names[0] + ', ' + names[1] + ' and ' + names[2] + like
    else:
        ans =  names[0] + ', ' + names[1] + ' and ' + other + like
    return ans

print(likes(names))
'''


''' #5Kyu

lst = [1, 0, 1, 2, 0, 1, 3] # returns [1, 1, 2, 1, 3, 0, 0]

def move_zeros(lst):
    zeros = lst.count(0)
    while zeros > 0:
        lst.remove(0)
        lst.append(0)
        zeros -= 1
    return lst

print(move_zeros(lst))

#inna werjsa lepsza
#better version

def move_zeros(lst):
    non_zeros = [x for x in lst if x != 0]
    zeros = [0] * lst.count(0)
    return non_zeros + zeros

print(move_zeros(lst))
'''


''' #6Kyu

seq = [1,2,2,3,3,3,4,3,3,3,2,2,1] #[0,1,0,1,0] #[1,1,2] #should return 2, because it occurs 1 time (which is odd).

def find_it(seq):
    for x in seq:
        y = seq.count(x)
        if y % 2 != 0:
            break
    return x

print(find_it(seq))
'''


''' #6Kyu

text = "aabBcccccde" # -> 2 # 'a' and 'b'

def duplicate_count(text):
    txt = text.lower()
    no_dupli = set(txt)
    counter = 0

    for x in no_dupli:
        y = txt.count(x)
        if y > 1:
            counter += 1
        
    return counter

print("Duplicates:", duplicate_count(text))
'''


''' #6Kyu

sentence = "is2 Thi1s T4est 3a"

def order(sentence):
    word = sentence.split()
    return ' '.join(sorted(word, key=extract_number))

def extract_number(one_word):
        for ch in one_word:
            if ch.isdigit():
                return int(ch)
            
print (order(sentence))


#second version
def order(sentence):
    word = sentence.split()
    all = sorted(word, key=lambda x:int([ch for ch in x if ch.isdigit()][0]))
    new = ' '.join(all)
    return new
'''


''' #7Kyu

l = [1,2,'a','b',3,'c',4,'d']

def filter_list(l):
    number = []
    for x in l:
        if type(x) == int:
            number.append(x)

    return number

print(filter_list(l))
'''


''' #6Kyu

#Codewars Problem: Counting Bits
n = 1234 #output: 5

def count_bits(n):
    #bits = bin(n)[2:].count('1')
    #bits = bits[2:].count('1')
    return bin(n)[2:].count('1')

print(count_bits(n))
print (n)
'''


''' #7Kyu

def square_digits(num):
    lista = []
    num_str = str(num)
    for x in num_str:
        square = int(x) **2
        for a in str(square):
            lista.append(a)
            wynik = ''.join((lista))
    return int(wynik)
'''


''' #7Kyu

def odd_or_even(arr):
    total = sum(arr)
    if total % 2 == 0:
        return "even"
    else:
        return "odd"
'''


''' #7Kyu

def reverse_words(text):
    a = text.split(" ")
    a.reverse()
    a = " ".join(a)
    a = a[::-1]
    return a
'''
